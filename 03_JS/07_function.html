<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <!-- 태초에 함수는 함수라고 불렀다 -> 그러나 class라는 게 생기면서 class안에 들어가게 됐는데,
  -> 그 이후로 메소드라는 이름으로 바뀌어 불려오고 있다.
  (c언어는 class가 없어서 함수라고 부름.) -->

  <script>
    
    /*
      선언 함수 (★많이 사용함)
      1. 함수의 이름이 있다.
      2. 함수 정의(함수를 만드는 것)와 함수 호출(함수를 사용하는 것)로 구분한다.
      3. 함수 정의 형식
        function 함수명([매개변수]){
          함수 본문
          return 반환값;
        }
      4. 함수 호출 형식
        함수명([인수]);
      // JS는 타입이 없기 때문에(var라는 변수 하나로 다 씀), 함수를 만들 때는 앞에 function을 적어준다.
      // 타입이 존재하지 않기 때문에 반환타입이라는 것도 없다.
    */

     // 함수 호출
     myFunc1();

    // 함수 정의 (호이스팅 대상이므로 위치가 아래에 있어도 언제나 먼저 처리된다.)
    function myFunc1(){
      console.log('myFunc1 실행');
    }

    // ↑↑↑ 대부분의 언어들은 정의 없이 호출부터 하면 오류가 난다.
    // 하지만 JS에서는 호이스팅으로 함수 정의 전에 호출부터 가능.
    // (함수 호출은 호이스팅 아님, 함수 정의가 호이스팅 대상임.)
  </script>

  <script>
    
    /*
      익명 함수
      1. 함수의 이름이 없다.
      2. 호이스팅 대상이 아니다. (함수 정의를 반드시 먼저 해야 한다.)
      3. 함수 정의 형식
        1) 일반 익명 함수
          function 함수명([매개변수]){
            함수 본문
            return 반환값
          }
        2) 화살표 익명 함수
          ([매개변수])=>{
            함수 본문
            return 반환값
          } 
          // 약간의 차이만 있고, 1) ~ 2) 거의 같다.
          // 최근에는 화살표 익명 함수를 권장하고 있다.
      4. 함수 호출 형식  [ 1), 2) 번 방식 거의 안씀, ★ 3)을 많이씀 ) ]
        1) 함수를 변수에 저장하기
          (1) 일반 익명 함수
            var 함수명 = function(){

            }
            함수명();
          (2) 화살표 익명 함수
            var 함수명 = ()=>{

            }
            함수명();
        2) 자기 호출 (함수 정의와 함수 호출이 동시에 진행되는 방식)
          (1) 일반 익명 함수
            (function(){

            })();
          (2) 화살표 익명 함수
            (()=>{

            })();
        3) 이벤트 리스너로 등록하기
            (1) 일반 익명 함수
              문서객체.addEventListener('이벤트', function(){

            })

            (2) 화살표 익명 함수
              문서객체.addEventListener('이벤트', ()=>{

              });
        *이벤트의 대표적인 것에는 '사용자의 클릭'이 있다. (클릭하면 동작하는 것)
    */

    // 1) 함수를 변수에 저장하기
    var myFunc2 = function(){
      console.log('myFunc2 실행');
    }
    myFunc2();

    // 2) 자기 호출
    (function(){
      console.log('자기 호출 실행');
    })();

    // 3) 이벤트 리스너로 등록하기
    document.addEventListener('dblclick', function(){
      console.log('이벤트 리스너 실행');
    });
    // document 는 문서 전체를 의미해서 어디든 더블클릭 하면 됨.

  </script>

  <script>

    /*
      인수와 매개변수
      1. 매개변수를 선언할 때는 선언 키워드(var, let, const)를 사용하지 않는다. (매개변수는 변수명만 작성한다.)
      2. 디폴트 매개변수 처리가 가능하다.
        1) 변수를 선언하고 어떤 값도 저장하지 않으면 undefined 값을 가진다.
        2) 매개변수로 인수를 전달하지 않으면 매개변수는 undefined 값을 가진다.
        3) 매개변수의 undefined 여부에 따라 매개변수의 초기화 작업을 진행할 수 있다.
        4) 매개변수에 디폴트 값을 직접 저장할 수 있다.
      3. 전개 연산자(...)가 존재한다. (자바에서는 int...a 와 같음(배열) )
        1) 인수의 개수가 정해지지 않은 경우에 사용한다.
        2) 매개변수를 배열로 처리한다.
      4. 인수를 저장하는 arguments 객체가 있다.
        1) 매개변수를 선언하지 않아도 모든 인수는 arguments 객체에 저장된다.
        2) arguments 객체는 배열과 유사하게 동작한다.
    */

    // 인수와 매개변수
    function myFunc3(a){
      console.log(a);
    }
    myFunc3(10);
    myFunc3('Hello World');
    var a = true; // 만약 호출 함수가 해당 구문보다 위에 있으면, 호이스팅때문에 var = a; 선언부가 위로 올라가기에 아직 값이 없으니 undefined 뜸.
    myFunc3(a)

    // 익명 함수 - 인수와 매개변수
    var myFunc4 = (b)=>{  // 변수에 함수를 저장시키면, 이 변수는 곧 함수다.
      console.log(b);
    }
    myFunc4(100);
    myFunc4('안녕하세요');
    var b = false;
    myFunc4(b);

    ((c)=>{
      console.log(c);
    })(1000);   // 1000 이 c로 전달되서 사용된다.

    // 디폴트 매개변수
    function myFunc5(a){
      if(a === undefined){  // a로 전달된 인수가 없으면 a = 0 이다.
        a = 0;
      }
      console.log(a);
    }
    myFunc5(10);
    myFunc5();

    // 디폴트 매개변수( ES6 = 애크마스크립트(=자바스크립트 원래 명칭) )
    function myFunc6(a = 0){
      console.log(a);
    }
    myFunc6(10);
    myFunc6();

    // 전개 연산자(...)
    function myFunc7(...a){
      for(let i = 0; i < a.length; i++){
        console.log(a[i]);
      }
    }
    myFunc7(1, 2, 3, 4, 5);

    // arguments 객체
    function myFunc8(){
      for(let i = 0; i < arguments.length; i++){  // arguments 자체가 원래 존재하는 객체이다.
        console.log(arguments[i]);
      }
    }
    myFunc8(6, 7, 8, 9, 10);
  </script>

  <script>
  /*
    반환(return)
    1. 반환 타입을 작성하지 않는다.
    2. return 반환값; 을 통해서 값을 반환할 수 있다.
    3. return; 을 통해서 함수를 종료할 수 있다.
  */
    
    function myMax(a, b, c){
      if(isNaN(a) || isNaN(b) || isNaN(c)){ // a,b,c, 가 숫자가 아니면 비교하지 않겠다.(종료 = undefined)
        return;
      }
      let max = a;
      if(b > max) max = b;
      if(c > max) max = c;
      return max;
      // 자바에서는 return 과 return max; 같이 쓸 수 없다. (JS만 가능.)
    }
    function myMin(a, b, c){
      if(isNaN(a) || isNaN(b) || isNaN(c)){
        return;
      }
      let min = a;
      if(b < min) min = b;
      if(c < min) min = c;
      return min;
    }
    function myMedian(a, b, c){
      if(isNaN(a) || isNaN(b) || isNaN(c)){
        return;
      }
      /*
      let median;
      if(a >= b){
        if(b >= c) median = b;      // a b c
        else if(a <= c) median = a; // c a b
        else median = c;            // a c b
      } 
      else if(a > c) median = a;  // b a c
      else if(b > c) median = c;  // b c a
      else median = b;            // c b a
      return median;
      */
     let median;
     if((b >= a && a >= c) || (c >= a && a >= b)){  // b a c, c a b
      median = a;
    } else if((a >= b && b >= c) || (c >= b && b >= a) ) { // a b c, c b a
      median = c;
    }   
     return median;
    }
    console.log(myMax(1, 2, 3));
    console.log(myMin(1, 2, 3));
    console.log(myMedian(1, 2, 3));

  </script>

  <script>
    /*
      콜백 함수
      1. 함수에 함수를 전달할 수 있는 개념이다.
      2. 인수(함수) -> 매개변수(함수를 저장한 변수) 흐름으로 동작한다.
      3. 함수를 전달 받은 함수는 매개변수를 함수 호출하듯이 처리하여 전달 받은 함수를 실행한다.
    */

    // 인수가 없는 콜백
    function myFunc9(a){
      a();
    }
    myFunc9(function(){
      console.log('함수 호출');
    })
    
    // 인수가 있는 콜백
    function myFunc10(a, b, callback){
      callback(a, b);
    }
    myFunc10('Hello', 'World', function(x, y){
      console.log(x, y);
    });
    // Hello 는 a로 갔다가 callback(a, b)의 a로 가고 익명함수니까 다시 function의 x로 가서, console.log(x, y)의 x로 가서 출력되었다.
    // World 도 마찬가지.
  </script>

  <script>

    /*
      재귀 호출
      1. recursive call
      2. 어떤 함수가 자신을 호출하는 것을 의미한다.
      3. 반복 동작을 구현할 때 사용한다.
    */

    /*
      factorial 구하기
      5! = 5*4! = 5*4*3*2*1 ('5팩토리얼'로 읽음)
      4! = 4*3! = 4*3*2*1
      3! = 3*2! = 3*2*1
      2! = 2*1! = 2*1
      1! = 1
    */
    function factorial(a){
      if(a === 1){
        return 1;
      } else {
        return a * factorial(a-1);  //팩토리얼이 한 번에 계산되서 나옴 ( ex:5*4*3*2*1 )
      }
    }


  </script>
</body>
</html>